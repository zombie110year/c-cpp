##################
变量、常量与表达式
##################

变量的声明与定义
================

.. note:: *声明* 声明符号, *定义* 分配内存

变量是编程语言中最重要的概念之一,
一个变量, 在程序中是一个 **代表着某个内存空间** 的符号.
至于符号所代表的内存空间在何处, 这是由程序和操作系统所管理的.

变量具有类型, 不同类型的变量具有不同的大小, 也决定了对内存空间的解读方式.

在 :doc:`grammar` 中, 已经提到了基本的内置类型以及它们所占用的空间大小,
(单位: 字节):

+--------------------------+-----+
| char                     | 1   |
+--------------------------+-----+
| short int                | 2   |
+--------------------------+-----+
| int                      | 4   |
+--------------------------+-----+
| long int                 | 8   |
+--------------------------+-----+
| long long int            | 8   |
+--------------------------+-----+
| float                    | 4   |
+--------------------------+-----+
| double                   | 8   |
+--------------------------+-----+
| long double              | 16  |
+--------------------------+-----+
| unsigned short int       | 2   |
+--------------------------+-----+
| unsigned int             | 4   |
+--------------------------+-----+
| unsigned long int        | 8   |
+--------------------------+-----+
| unsigned long long int   | 8   |
+--------------------------+-----+

.. note:: 如果想要确认本机的情况, 编译并运行这个程序:

   .. literalinclude:: _code/show.sizeof.c
      :language: c
      :caption: show.sizeof.c

.. note:: void 类型

   注意到, 上面的代码 show.sizeof.c 中的 main 函数的形参表中不再是
   ``int argc, char *argv[]``, 而是 ``void``.

   这个类型只有两种使用情形:

   1. 用于函数形参, 表示此函数不接收任何参数
   2. 用于指针, 表示此指针可以指向任何类型的值, 详见 :ref:`void 指针`.

在 C 语言中, 要使用一个标识符, 必须在使用处之前存在相关的声明, 否则, 编译器会无法找到符号.

要进行变量的声明, 需要提供该变量的类型以及存储类型::

   auto int counter; // 声明一个 int 类型的自动变量.

所谓的存储类型, 就是该存储该变量的区域, 有以下四种:

.. sidebar:: 生存周期

   一个实体从产生到消亡的区间.

auto
   在函数作用域中声明的变量默认为自动存储类型.
   关于作用域的详细解释, 见 :doc:`scope`.

   所谓的自动变量, 就是当调用函数时, 在帧栈上创建,
   当函数调用结束, 则与帧一起被释放.

   也就是说, 生存周期为函数的生存周期.

static
   在全局作用域中声明的变量默认为静态存储类型.
   静态变量存储在程序的 *静态存储区* 中, 在整个程序的运行过程中一直存在.

   关于静态存储区的讨论, 见 :ref:`可执行文件的结构`.

register
   寄存器变量. 将会存储在 *寄存器(Register)* 中, 寄存器由 CPU 直接操作,
   并且容量和数目有限.

   当无法存入寄存器时, 此变量将降级为自动变量.

   常用于经常被修改的变量类型, 例如作为循环变量的整数或指针.
   并且, 此变量的实体大小必须在 CPU 的一个字长之内.

   x86_64 架构 CPU 的字长为 64 bit.

extern
   外部变量. 此变量仅声明符号, 而不分配空间.
   在 **链接** 阶段时, 此符号指向另一个目标代码中的同名变量.

   此类型的变量必须声明在全局作用域中.

.. literalinclude:: _code/show.type.storage.c
   :language: c
   :caption: show.type.storage.c
   :linenos:

除了 ``extern`` 存储类型之外, 其他的变量都会在声明之后定义.

在定义的同时为变量赋值被称为 *初始化(Initialization)*.

常量
====

如果要让一个变量在初始化之后不能再次被更改,
可以使用 ``const`` 关键字修饰此变量::

   const int CONST_EXAMPLE = 1;

这样的变量被称为 "常量",
在程序中, 常常使用大写字母来命名常量.

``const`` 关键字同样可以修饰 :ref:`常量指针与指针常量` 和 :ref:`常量函数`.

但实际上, 常量仅仅是 "无法通过此标识符修改目标内存" 而已,
通过指针运算仍然可以定位到将常量所表示的内存空间进行修改.

枚举常量
========

在某些时候, 会需要用到一系列常量, 例如用来表示一周的星期名::

   const int Monday = 1;
   const int Tuesday = 2;
   // ...

或者, 定义错误处理时所需要的错误码::

   const int PASS = 0;
   const int UNKNOWN_ERROR = -1;
   // ...

这些都可以使用一个 ``enum`` 枚举体来进行定义:

.. literalinclude:: _code/show.enum.c
   :language: c
   :lines: 3-8

enum 枚举体从 0 开始为其中的成员赋值. 每一个成员都是可直接使用的常量.
它们的大小和数据解读方式和 ``int`` 一致.

也可以为其中的某几个成员赋值, 接下来的成员会按照前一个成员的值进行递增:

.. literalinclude:: _code/show.enum.c
   :language: c
   :lines: 10-18

每一个 enum 结构体的成员实际上都是 int 类型, 因此不同的 enum 结构体中定义的常量可以互相比较:

.. literalinclude:: _code/show.enum.c
   :language: c
   :linenos:
   :caption: show.enum.c

运行结果如下

.. code::

   0 1 2 3
   0 1 2 3 4 5 6
   1

变量的类型转换
==============

变量的类型具有两个大类: 整数和浮点数,
在这两个大类之下, 分了 int, unsigned int, long int, char; float, double 等小类.

当一个变量将值赋给另一个变量时, 如果这两个变量的类型不同, 则有可能发生自动类型转换或者编译错误.

自动类型转换时, 编译器会向不损失信息的方向进行转换. 也就是从尺寸小的类型向尺寸长的类型转换.

char 可以向 int 自动转换, float 可以向 double 自动转换. 但反过来就会发出警告.

可以手动指定转换格式, 采用在值前添加 ``(类型名)`` 的语法::

   char ch = (char) 10.0;
   // 否则会发出 double -> char 的警告

这常常用于对 void 指针进行显式转换::

   void *getItem(/* 形式参数 */);

   int value = *(int *)getItem(/* 实际参数 */);
