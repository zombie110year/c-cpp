##########
C 语言语法
##########

从自然语言到形式语言
====================

我们日常生活中所讲所书的语言就是 *自然语言* , 例如汉语, 英语等.
自然语言是经过长时间的自然演化而形成的. 在演化过程中, 没有完善的规则
(虽然也有人希望能够总结出规则, 但总有例外情况, 并且总会有词语的含义不可预料的发生变化).
在很多时候, 只能依靠学习经验来从语言中提取信息.
这也就是为什么我们要花十几年的时间学习语文, 才能与人流畅的交流.

而 *形式语言* 则是在设计时就拥有了严格的语法, 在各个层次上对语言的表达进行规定.

形式语言与自然语言在结构上具有一些相同的要素, 例如:

.. _`语法的要素`:

.. list-table:: 语法的要素

   *  -  文法(Grammar)
      -  句子组成段落、文章的规则
   *  -  句法(Syntax)
      -  词与词之间组成句的规则
   *  -  词法(Lexical)
      -  字与字之间组成词的规则
   *  -  字(Token)
      -  最小语素

.. note::

   文法/语法/句法 经常混淆.

   -  Grammar 可译作 文法 或 语法
   -  Syntax 也可译作 句法 或 语法

   为了避免歧义, 本书使用 语法 作为上述内容的统称.
   文法和句法单独使用.

编程语言就是形式语言的一种, 而其他的形式语言还有数学表达式, 化学式等等.
例如, :math:`1+1=3` 是一个符合数学表达式的语法的 *句* , 而 :math:`1 a 1 = 2` 就不是.
虽然 :math:`1+1=3` 不是一个正确的等式, 但它的错误出在 **语义(Semantic)** 而非 **语法**,
而 :math:`1 a 1 = 3` 呢? 它缺少了运算符, 或者说在运算符的位置插入了一个代数符号.
这就是语法的错误了.

常见的语法错误有:

-  无效的 *字*, 例如, 在化学式中 :math:`$_2O` 是错误的,
   化学式中没有定义 :math:`$` 的含义.
-  错误的 *词*, 例如, :math:`\mathrm{Zm}^{2+}`,
   没有元素的缩写是 :math:`\mathrm{Zm}`.
-  错误的 *句*, 例如 :math:`1+=3 \; 2`, 词之间的顺序出现了错误.

自然语言和形式语言也存在不同之处.

.. todo:: 编译原理, 上下文无关文法与上下文相关文法

歧义性(Ambiguity)
   自然语言充满歧义, 人们通过上下文的线索和自己的常识来消除歧义
   (或者不能消除而造成误解).
   形式语言的设计要求是清晰的、毫无歧义的, 这意味着每个语句都必须有确切的含义, 与上下文无关.
冗余性(Redundancy)
   为了消除歧义减少误解或者提高艺术性, 自然语言引入了相当多的冗余.
   而形式语言只负责基本表意, 更加紧凑, 极少有冗余.
与字面意思的一致性
   自然语言充斥着成语和隐喻(Metaphor) , 我在某种场合下说 "葡萄架子倒了",
   可能并不是说哪里的葡萄架子倒了, 而是说某某人怕老婆.
   在某些语境下, 连 "睿智" 这种词也可以用来骂人.

   而形式语言中字面 (Literal) 意思就是真实意思.
   虽然表面上看起来存在例外, 例如转义序列.
   但实际上, 转义序列表示的也是它这个词所对应的字面含义.

   例如, C 语言用 ``\n`` 符号表示 *换行符*, 但是它和 ``n`` 并没有关系,
   ``\n`` 是换行符的字面量, 而 ``n`` 是字母 n 的字面量.

C 语言中的语素
==============

在 :ref:`语法的要素` 中, 提到了形式语言中存在的语素有: *字*, *词*, *句*, *文*.
让我们一一对应到 :ref:`hello.c` 中来看一看, C 代码中的哪些元素属于哪种语素.

第一行是预处理语句, 我们关注 main 函数的部分:

.. literalinclude:: _code/hello.c
   :language: c
   :linenos:
   :lines: 3-

在上面显示的代码中, 每一个字符,
例如 ``i`` , ``n``, ``t``, 空格 ... 等等,
就是 C 中的 *字*. 它们组合在一起、或者独立成词
(例如 ``for`` 循环中的变量 ``i``),
空白字符在词法分析中是被抛弃的,
编译器不认为空格这类空白字符能组词:

+------+-------------+
| 词   | 类型        |
+------+-------------+
| int  | 类型声明    |
+------+-------------+
| main | 函数名称    |
+------+-------------+
| (    | 开圆括号    |
+------+-------------+
| int  | 类型声明    |
+------+-------------+
| argc | 变量名称    |
+------+-------------+
| ,    | 逗号分隔符  |
+------+-------------+
| char | 类型声明    |
+------+-------------+
| ...  |             |
+------+-------------+

等等, 组成了代码中的 *词*

而语法分析则将词组成 *句*, 在 C 语言中, 一般将句称为 "表达式", 例如:

.. list-table::

   *  -  句
      -  含义
   *  -  ``printf("Hello World\n")``
      -  调用一个名为 ``printf`` 的函数,
         并将 ``"Hello World!\n"`` 作为参数传递

语义分析就会将 *句* 组成 *文* 了,
涉及到的主要结构有:

-  以 ``;`` 结尾的表达式构成 *语句*
-  包括在 ``{}`` 中的众多语句构成 *语句块*
-  各独立的语句, 语句块构成整个程序的 *文*.

C 语言中的词根据用途的不同, 可以分为:

标识符
   标识符是用来标识一个结构的符号, 类似于数学中的代数符号.
   C 语言中的标识符可以是 变量名、函数名、类型名等.
操作符
   操作符用来表示一个操作,
   例如 +-\*/ 等四则运算, 调用函数 ``()``, 访问数组 ``[]`` 等等.
   操作符一定需要操作数的存在,
   不同的操作符需要的操作数数目和位置不一定相同.

   操作数可以是标识符或者字面量这种能用来表示数据的符号.
分隔符
   像 ``{}``, ``;``, ``,`` 这种用于分隔其他词或划分一个范围的符号.
字面量
   在程序中直接表示数据的量.
关键字
   语言预先定义的有特殊作用的词, 用户不能修改其定义.

注释
====

C 语言可以在代码中添加说明性的 *注释(Comment)*,
注释在预处理阶段会被清除, 从而不影响程序的编译.

可用行注释, 从 ``//`` 符号到换行符都是注释::

   // 单行注释

块注释, 从 ``/*`` 到 ``*/`` 都是注释::

   /* 块注释 */

   /**
    * 也可以写成更好看的形式
    */

块注释不能嵌套, 当遇到第一个 ``*/`` 时, 就会退出注释.

内置类型与变量定义
==================

在 C 语言中, 一个 *变量* 就如同数学中的代数符号一般. 代数符号表示一个数值,
而变量则代表一个内存区域, 在这个内存区域中, 计算机能够存储、修改数值.

而 *类型* , 则是为了确定这个内存区域的大小, 以及计算机解读这个内存中数据的方式.

内置的类型, 总体上可以分为 *整数(Integer)*, *浮点数(Floating)* 两大类.
整数和浮点数在数据解析上有着本质上的差别, 可以参阅 :ref:`整数`, :ref:`浮点数` 来详细了解.
目前, 我们可以先忽略这些细节, 看看它们在 C 语言中的类型名是什么:

-  ``int``
-  ``float``, ``double``

``int`` 是标准整数, ``float`` 是单精度浮点数, 而 ``double`` 是双精度浮点数.
``int`` 的长度通常为 32 bit, 这是在 32 位平台和 64 位平台的情形.
如果在 16 位, 甚至更低的 8 位平台上, ``int`` 的长度可能不同.

``float`` 和 ``double`` 的长度通常为 32 bit, 64 bit.
它们的有效数字(对应到 10 进制)分别为 6~7 位和 15~16 位.

需要注意的是, 由于存储数据的空间有限,
当计算过程中的数据超出了范围, 就会发生 *溢出(Overflow)*,
从而导致数据失去其意义.

``int`` 类型的数据最多可以表示 :math:`[-2^{16}, 2^{16} - 1]` 范围的数值,
当数值已经到达 :math:`2^{16} - 1` (65535) 时,
如果再加一, 则所发生的就是未定义行为, C 标准中没有对此行为进行规定.

整数有 *有符号* 和 *无符号* 两种模式, ``int`` 默认是有符号的,
如果要使用无符号的整数, 则用 ``unsigned`` 修饰它.

``unsigned int`` 的范围为 :math:`[0, 2^{32}-1]`.
而当无符号整数发生溢出时, C 标准规定要将溢出的部分舍弃, 只留下后 32 bit 数值.
也就是当数值已经到达 :math:`2^{32}-1` (4294967295) 时, 再加 1 就变成了 0.
如此循环.

C 语言还提供了 ``short``, ``long`` 修饰符用来修饰 ``int`` 或 ``double``
类型, 分别表示 *短*, *长*.

另外还有一个 ``char`` 类型, 用来存储一个 *字节(Byte)*.
它就是一个只占一个字节的无符号整数.
它也被称为 *字符(Character)*, 不过这是在 ASCII 时代留下的称呼.
那个时候, 一个字符只需要一个字节就可存储,
而对于现代 Unicode 时代, 全球数以万计的各种字符, 已经远远不是一个字节就可存储的了.
因此, char 类型的 "字符" 含义已经不准确了.

不同长度的整数、浮点数占用了不同大小的内存空间, 在 x86_64 架构下, 这些类型所占的字节数分别为:

+--------------------------+-----+
| char                     | 1   |
+--------------------------+-----+
| short int                | 2   |
+--------------------------+-----+
| int                      | 4   |
+--------------------------+-----+
| long int                 | 8   |
+--------------------------+-----+
| long long int            | 8   |
+--------------------------+-----+
| float                    | 4   |
+--------------------------+-----+
| double                   | 8   |
+--------------------------+-----+
| long double              | 16  |
+--------------------------+-----+
| unsigned short int       | 2   |
+--------------------------+-----+
| unsigned int             | 4   |
+--------------------------+-----+
| unsigned long int        | 8   |
+--------------------------+-----+
| unsigned long long int   | 8   |
+--------------------------+-----+

如果 short, long 修饰符修饰了 int 类型,
那么也可以省略 ``int`` 这个单词, 表示的仍然是被修饰的 int.

变量可以通过 **类型名** **变量名** 的方式来进行定义::

   int example;

也可以在定义时为变量赋值, 这被称为 *初始化(Initialization)*::

   int example = 1;

一个未初始化变量所分配到的内存空间里可能已经存在垃圾值,
即此内存上次被使用后留下的值.

C 语言中, 存在 *定义(Define)* 与 *声明(Declare)* 的区别.
声明仅仅在程序中增加一个符号, 而定义则在声明符号之后, 为这个符号分配内存空间.

声明变量常应用于从其他目标代码中引入全局变量情形. 可以使用关键字 ``extern`` 来进行声明::

   extern int ANATHOR;

当然, 由于未分配空间, 一个声明的符号是不能在此初始化的.
它应当在其他位置被 **定义**, 在此声明之后引用它.

可以在一个值之前使用 ``(类型)`` 的语法对数据进行强制类型转换.
从 浮点数 转换到 整数时会发生数据损失, 小数部分将被舍弃.
(并不是所想的那种将浮点数二进制数据强制用整数方法解析)

从短类型到长类型的转换是无损的, 而从长类型到短类型的转换也会发生损失,
超出范围的部分会被舍弃, 并且编译器会提出警告, 这种转换是不被提倡的.
如果确定从长到短的转换是必须的, 可以直接忽略此警告,
不过大多数情况下这种转换都是不合理的设计.

不同类型的字面量
================

在程序中, 可以用字面量的形式将数据直接写在源码中.
编译器会将字面量按照其大小、形式解析为对应类型的数据.

例如, ``1`` 会被解析成 int 类型, 而当数值超过 int 的表示范围, 则会扩展为 long int.
而 ``1.0`` 则会被解析成 float 类型.

可以利用强制类型转换将字面量转换为需要的类型.

比较特殊的两种字面量是字符与字符串, 它们分别使用单引号 ``''`` 和双引号 ``""`` 来表示.

在单引号中的被解析为字符, 例如 ``'0'``, 它的 ASCII 码为 48, 从而被解析为 ``(char) 48``.
C 语言中的字符只有一个字节, 所以只能存入 0~256 范围内的值, 也就是 ASCII 码中的符号.
其中包括转义序列. ASCII 码表可以在网上轻松找到, 这里就不贴出了.

在双引号中的被解析为字符串, 例如 ``"hello"``,
字符串就是字符所组成的有序序列, 其中的每一个元素都是字符, 也就是一个字节大小的无符号整数.
在将源代码的字符编码设置为 *UTF-8* 时, ``"你好"`` 这样的字符串也是有效的,
虽然 "你好" 这两个中文字符明显超出了 ASCII 的范围.
由于 Unicode 的传输格式 UTF-8 将 Unicode 字符转换成多个字节组成的序列,
因此正好可以用 char 这种类型来存储. "你好" 这两个字符占用 6 个字节.

字符串的末尾用 ASCII[0] -- ``\0`` 来标志, 这种方式被称为 C-style 字符串.
因此, 字符串 "hello" 实际占用了 6 个字节.

操作符
======
