###########
编译 C 程序
###########

程序的基本概念
==============

*程序 (Program)* 告诉计算机应如何完成一个计算任务,
这里的计算可以是数学运算, 比如解方程,
也可以是符号运算, 比如查找和替换文档中的某个单词.
从根本上说, 计算机是由数字电路组成的运算机器,
只能对数字做运算, 程序之所以能做符号运算,
是因为符号在计算机内部也是用数字表示的.
此外, 程序还可以处理声音和图像,
声音和图像在计算机内部必然也是用数字表示的,
这些数字经过专门的硬件设备转换成人可以听到, 看到的声音和图像.

程序由一系列 *指令 (Instruction)* 组成,
指令是指示计算机做某种运算的命令, 通常包括以下几类:

输入 (Input)
   从键盘, 文件或者其它设备获取数据.

输出 (Output)
   把数据显示到屏幕, 或者存入一个文件, 或者发送到其它设备.

基本运算
   执行最基本的数学运算 (加减乘除) 和数据存取.

测试和分支
   测试某个条件, 然后根据不同的测试结果执行不同的后续指令.

循环
   重复执行一系列操作.

对于程序来说, 有上面这几类指令就足够了.
你曾用过的任何一个程序, 不管它有多么复杂, 都是由这几类指令组成的.
程序是那么的复杂, 而编写程序可以用的指令却只有这么简单的几种,
这中间巨大的落差就要由程序员去填了, 所以编写程序理应是一件相当复杂的工作.
编写程序可以说就是这样一个过程: 把复杂的任务分解成子任务,
把子任务再分解成更简单的任务, 层层分解, 直到最后简单得可以用以上指令来完成.

编程语言 (Programming Language) 分为低级语言 (Low-level Language) 和高级语言 (High-level Language).
机器语言 (Machine Language) 和汇编语言 (Assembly Language) 属于低级语言,
直接用计算机指令编写程序. 而C, C++, Java, Python等属于高级语言,
用 *语句(Statement)* 编写程序, 语句是计算机指令的抽象表示.
举个例子, 同样一个语句用C语言, 汇编语言和机器语言分别表示如下:


.. table:: 一个语句的三种表示方式
   :name: 一个语句的三种表示方式
   :widths: grid
   :align: center

   +----------+--------------------------+
   | 编程语言 | 表示形式                 |
   +----------+--------------------------+
   | C语言    | .. code-block:: c        |
   |          |                          |
   |          |     a = b + 1;           |
   +----------+--------------------------+
   | 汇编语言 | .. code-block:: asm      |
   |          |                          |
   |          |     mov 0x804a01c, %eax  |
   |          |     add $0x1, %eax       |
   |          |     mov %eax, 0x804a018  |
   +----------+--------------------------+
   | 机器语言 | .. code-block:: hexdump  |
   |          |                          |
   |          |     a1 1c a0 04 08       |
   |          |     83 c0 01             |
   |          |     a3 18 a0 04 08       |
   +----------+--------------------------+

计算机只能对数字做运算, 符号, 声音, 图像在计算机内部都要用数字表示,
指令也不例外, 上表中的机器语言完全由十六进制数字组成.
最早的程序员都是直接用机器语言编程, 但是很麻烦,
需要查大量的表格来确定每个数字表示什么意思, 编写出来的程序很不直观,
而且容易出错, 于是有了汇编语言, 把机器语言中一组一组的数字用 *助记符(Mnemonic)*
表示, 直接用这些助记符写出汇编程序, 然后让 *汇编器(Assembler)* 去查表把助记符替换成数字,
也就把汇编语言翻译成了机器语言. 从上面的例子可以看出,
汇编语言和机器语言的指令是一一对应的, 汇编语言有三条指令, 机器语言也有三条指令,
汇编器就是做一个简单的替换工作,
例如在第一条指令中, 把 ``movl ?,%eax`` 这种格式的指令替换成机器码 ``a1 ? ,  ?``
表示一个地址, 在汇编指令中是 ``0x804a01c`` , 转换成机器码之后是 ``1c a0 04 08``
(这是指令中的十六进制数的小端表示)

从上面的例子还可以看出,
C 语言的语句和低级语言的指令之间不是简单的一一对应关系,
一条 ``a=b+1;``
语句要翻译成三条汇编或机器指令, 这个过程称为 *编译(Compile)*,
由 *编译器(Compiler)* 来完成, 显然编译器的功能比汇编器要复杂得多.
用 C 语言编写的程序必须经过编译转成机器指令才能被计算机执行,
编译需要花一些时间, 这是用高级语言编程的一个缺点,
然而更多的是优点.
首先, 用C语言编程更容易, 写出来的代码更紧凑, 可读性更强,
出了错也更容易改正. 其次, C 语言是 *可移植的(Portable)*
或者称为 *平台无关的 (Platform Independent)*.

平台这个词有很多种解释, 可以指 *计算机体系结构(Architecture)*,
也可以指 *操作系统(Operating System)*, 也可以指开发平台 (编译器, 链接器等) .
不同的计算机体系结构有不同的 *指令集 (Instruction Set)*, 可以识别的机器指令格式是不同的,
直接用某种体系结构的汇编或机器指令写出来的程序只能在这种体系结构的计算机上运行,
然而各种体系结构的计算机都有各自的 C 编译器, 可以把 C 程序编译成各种不同体系结构的机器指令,
这意味着用C语言写的程序只需稍加修改甚至不用修改就可以在各种不同的计算机上编译运行.
各种高级语言都具有 C 语言的这些优点,
所以绝大部分程序是用高级语言编写的,
只有和硬件关系密切的少数程序 (例如驱动程序) 才会用到低级语言.
还要注意一点, 即使在相同的体系结构和操作系统下,
用不同的 C 编译器 (或者同一个 C 编译器的不同版本) 编译同一个程序得到的结果也有可能不同,
C 语言有些语法特性在C标准中并没有明确规定,
各编译器有不同的实现, 编译出来的指令的行为特性也会不同,
应该尽量避免使用不可移植的语法特性.

如何编写一个 C 程序
===================

要编译一个 C 程序, 首先需要提供源代码. 源代码都是纯文本,
随便打开一个 "文本编辑器"
(Windows 下的 notepad.exe, GNU 中的 gedit, 或者 vim, emacs, sublime text, vscode 等等)
就可以编辑. 但是不能使用 Word 之类的 "文字排版软件", 这些软件会在文件中保存样式信息,
插入二进制资源或者使用特殊的标记语法, 就不是 C 编译器可以解读的纯文本了.

使用文本编辑器编写一份 C 源代码. 一个有实用意义的程序通常还需要链接 C 标准库.
C 标准库提供的功能需要通过在自己编写的 C 代码中包含对应的头文件才能使用.
自己编写的 C 源代码一般在保存在 ``.c`` 后缀的文件中, 在这个文件中编写程序的主要逻辑,
而在 ``.h`` 后缀的文件中编写此程序想要被其他源代码文件引用的类型、变量、函数等.
``.c`` 文件一般称作 "源代码", 而 ``.h`` 文件一般称作 "头文件".

下面是一个经典的 Hello World 程序:

.. _`hello.c`:

.. literalinclude:: _code/hello.c
   :language: c
   :caption: hello.c
   :linenos:

第一行的 ``#include <stdio.h>`` 是一个 *预处理* 指令,
作用就是包含 C 标准库头文件 ``stdio.h`` 中的内容.
在这个文件中, 提供了 C 标准库与输入输出有关的函数声明与类型定义.

通过引入头文件中的声明, 才能在编译过程中正确地链接到 C 标准库中的符号.

之后的内容就是编辑的 C 代码, C 代码从一个 ``main`` 函数开始,
这被称为 `程序入口`_.

编译过程
========

对于传统的编译过程, 如使用 clang 进行编译, 我们会使用这样的命令行:

.. code-block:: sh

   clang -Wall -g -o hello hello.c

-  ``clang`` 要执行的程序名称, clang 是 Clang 编译器用来编译 C 语言的可执行程序.
-  ``-Wall`` clang 程序的一个参数, 意思是报告所有警告.
   警告是指在程序中那些不算错误, 但是可能导致程序运行不正常的代码.
-  ``-g`` clang 程序的一个参数, 意思是保留调试信息. 只有保留调试信息, 才能在调试时找到程序片段对应的源代码.
-  ``-o hello`` 设置输出文件的路径, 默认为 ``a.out``
-  ``hello.c`` 剩下的参数表示输入的源代码路径.

在执行上述指令时, 编译器做了这些事(可以使用参数 ``-save-temp`` 保存编译过程中的临时文件):

1. **预处理**: 首先将源代码 "喂" 给预处理器.
   预处理将会展开文件中的预处理指令与宏.
   C/C++ 中使用的预处理指令都是以 ``#`` 开头的.
   例如 :ref:`hello.c` 中第一行的 ``#include``.
   这个指令会将 ``/usr/include/stdio.h`` 中的内容包含到当前文件中来.
   并且 stdio.h 中的预处理指令与宏也会被展开.

现在, 我们得到了预处理后的源代码文件. 我们可以看到,
在文件开头的 ``#include <stdio.h>`` 已经变成了长达 700 多行的代码.
而在文件的尾部, 我们刚定义的 ``main`` 函数还是保持了原样没有改变.

.. literalinclude:: _code/hello.i
   :language: c
   :caption: hello.i
   :linenos:
   :lines: 1-10,729-

.. note:: 中间的 700 多行代码被剪掉了

2. **编译**: 在得到预处理后的代码之后, 这段代码就将喂给编译器进行处理.
   编译器会将代码编译成 "汇编" 代码. 关于汇编代码, 我们需要知道的是:

   -  汇编代码与 CPU 执行的机器码一一对应
   -  不同的 CPU 只能执行其指令集所实现的代码

   因此, 也是整个编译过程最重要的一步. 也是以这一步来命名了整个编译过程.

.. literalinclude:: _code/hello.s
   :language: asm
   :caption: hello.s
   :linenos:

3. **汇编**: 得到汇编代码之后, 就直接一步一步地将它翻译成机器码就好了.
   这一步之后, 得到了二进制目标代码 ``hello.o`` (有删减, 只保留了消息较密集的部分).

.. literalinclude:: _code/hello.o.txt
   :language: hexdump
   :caption: hello.o(有删减)
   :lines: 1-15,34-43
   :emphasize-lines: 8-9

使用 Linux 程序 xxd 将整个文件转换成了可读性更好的形式,
整个文件被分为三栏::

   <地址>:   <各地址上的字节>                         <字节对应的字符>
   00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............

``.`` 号表示这个字节没有对应的可显示字符.
还可以发现, 我们要打印的字符串 "Hello World!" 也出现在了目标代码里.

4. **链接**: 得到了二进制目标代码, 但是这个程序仍然不可执行.
   并且, 还注意到在源代码中使用的 :c:func:`printf` 还仅仅是声明,
   可没有定义对应的实现呢(在 hello.o 中, 编译器留下了 ``llvm_addrsig.printf`` 记号).
   因此, 还需要将中间代码与 C 标准库相链接, 把 printf 的代码与 printf 这个符号相关联.

.. literalinclude:: _code/hello.txt
   :language: hexdump
   :caption: hello(有删减)
   :lines: 1,43-46

.. 觉得太长, 后面的行就不要显示了 63-71,257-289,513-529,771-777,873-921

链接完成了之后, 终于得到可执行程序 ``hello`` 了.
现在, 让我们在终端运行它一下:

.. code:: bash

   ./hello

.. code::

   Hello World!

另外, clang 还会生成一个 ``hello.bc`` 文件, 那是 LLVM 的中间码.
它的生成是 LLVM 调用后端编译之前的一步.

.. list-table::

   *  -  编译过程
      -  Clang 编译过程
   *  -  .. graphviz:: ../_static/graphviz/intro.compile.gv
      -  .. graphviz:: ../_static/graphviz/intro.compile.clang.gv

程序入口
========

一个程序必须要有一个开始执行的位置, 对于 C 程序来说, 这个入口就是函数 ``main``,
所以你能在所有 **编译得到可执行文件的源代码** 中看到一个名为 ``main`` 的函数.

为什么要强调是 **得到可执行文件的源代码** ?

还记得在 `编译过程`_ 中提到的最后一个步骤: *链接* 吗,
在这个步骤中, 链接的目标 -- libc 就是一个链接库文件,
在链接库文件中, 可以不包含 ``main`` 函数.

链接库中存储了编译后的程序代码以及它们的符号,
可以链接到其他函数中使用. 具体的用法见 :doc:`library`.

继续说主函数, 在 :ref:`hello.c` 中, 主函数的 *形参(Parameter)* 表为 ``int argc, char *argv[]``:

.. literalinclude:: _code/hello.c
   :language: c
   :lines: 3

这是为了能够从命令行接收参数. ``argc`` 是所传入参数的数目,
``argv`` 则是存储了指向每一个参数的首地址的指针.
参数的类型都是字符串.
你可以使用 C 标准库提供的 :c:func:`atoi`, :c:func:`atof` 来将字符串解析为对应的整数或浮点数.
这两个函数的声明包含在头文件 ``stdlib.h`` 中.

当从终端调用程序时, 可以这样向程序传递参数:

.. code-block:: sh

   ./hello arg1 arg2 arg3

如此, 则 ``argc`` 的值将会为 4, ``argv`` 则是一个指向四个字符串的指针数组:

.. code::

   argv[0] -> "./hello"
   argv[1] -> "arg1"
   argv[2] -> "arg2"
   argv[3] -> "arg3"

``argc`` 和 ``argv`` 都是惯用名, 并非必须这么做, 你也可以这么命名::

   int main(int argument_counts, char *argument_variables[]) {

练习
====

1. 在自己的机器上编译并运行 hello.c 程序::

      #include <stdio.h>

      int main(int argc, char *argv[]) {
         printf("Hello World!\n");
         return 0;
      }


2. 去掉 :ref:`hello.c` 中的 ``#include <stdio.h>``, 看看编译器报错是什么.
3. 用 ``extern int printf(const char *restrict, ...);``
   代替 ``#include <stdio.h>``, 看看能否重新编译. 思考头文件的作用::

      extern int printf(const char *restrict, ...);

      int main(int argc, char *argv[]) {
         printf("Hello World!\n");
         return 0;
      }

.. todo:: 练习的参考答案

   1. 使用命令行 ``clang hello.c`` 生成的 ``a.out`` 就是可执行文件.
   2. 由链接器报出 undefined label 之类的错误
   3. 此代码应当能成功编译, 并正常运行. 头文件就是提供了相关的函数以及变量声明,
      在链接步骤后, 这些符号将指向标准库中的代码.
