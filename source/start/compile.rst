###########
编译 C 程序
###########

在开始学习 C 语言的语法之前, 先来了解如何将源代码编译成可执行的程序.

.. todo::

   由于我们选择了无 IDE 的 clang 开发环境,
   可没有按钮让我们来点.

   因此, 让我们先来认识一下命令行.

   终端就是让计算机的操作员与计算机进行交互(输入或输出)的程序或设备.
   可分为图形终端和字符终端.

   大多数人第一次使用计算机想必用的都是 Windows 操作系统吧,
   当你开机之后, Windows 便会自动启动它的图形界面 -- 桌面, 这就是一种 *图形终端* .
   你可以在桌面上用键盘打字, 用鼠标点击或拖曳进行交互, 并在屏幕上阅读文字, 观看视频等.

   如果你找到一个叫做 "命令提示符" (cmd.exe) 的程序,
   你一启动它, 就蹭地弹出来一个黑漆漆的窗口, 里面还有惨白的字符在闪烁;
   或者运行 "PowerShell", 这是微软退出的新的 "命令提示符", 弹出来蓝莹莹的窗口.

   总之, 要么黑得瞎眼, 要么蓝得刺眼, 都不是什么好的体验.
   (不过配置一下也是可以很好看的)

   这就是在图形界面中打开的 *字符终端模拟器* ,
   简称终端模拟器, 用于在图形界面中以字符终端的方式与计算机交互.

   如果想要纯粹的字符终端呢?
   抱歉, 这种使用体验极差的东西几乎已经绝迹了, 你得去没有屏幕的地方找它.

   好吧, 言归正传. 当我们进入 Linux 系统的命令行.

   在字符终端中, 会首先运行 "命令行解释器", 或者称为 "Shell" 的一类程序.
   它接收你在命令行输入的命令, 并在执行它之后返回运行的结果.

   对于大多数命令行, 都是以一个换行输入一条命令.

编译过程
========

先准备一个可编译的 C 代码源文件:

.. _`hello.c`:

.. literalinclude:: _code/hello.c
   :language: c
   :caption: hello.c
   :linenos:

.. sidebar:: 编译过程图示

   .. graphviz:: ../_static/graphviz/intro.compile.gv

对于传统的编译过程, 如使用 gcc 进行编译, 我们会

1. **预处理**: 首先将源代码 "喂" 给预处理器.
   预处理将会展开文件中的预处理指令与宏.
   C/C++ 中使用的预处理指令都是以 ``#`` 开头的.
   例如 :ref:`hello.c` 中第一行的 ``#include``.
   这个指令会将 ``/usr/include/stdio.h`` 中的内容包含到当前文件中来.
   并且 stdio.h 中的预处理指令与宏也会被展开.

现在, 我们得到了预处理后的源代码文件. 我们可以看到,
在文件开头的 ``#include <stdio.h>`` 已经变成了长达 700 多行的代码.
而在文件的尾部, 我们刚定义的 ``main`` 函数还是保持了原样没有改变.

.. literalinclude:: _code/hello.i
   :language: c
   :caption: hello.i
   :linenos:
   :lines: 1-10,729-

.. note:: 中间的 700 多行代码被剪掉了

2. **编译**: 在得到预处理后的代码之后, 这段代码就将喂给编译器进行处理.
   编译器会将代码编译成 "汇编" 代码. 关于汇编代码, 我们需要知道的是:

   -  汇编代码与 CPU 执行的机器码一一对应
   -  不同的 CPU 只能执行其指令集所实现的代码

   因此, 也是整个编译过程最重要的一步. 也是以这一步来命名了整个编译过程.

.. literalinclude:: _code/hello.s
   :language: c
   :caption: hello.s
   :linenos:

3. **汇编**: 得到汇编代码之后, 就直接一步一步地将它翻译成机器码就好了.
   这一步之后, 得到了二进制目标代码 ``hello.o`` (有删减, 只保留了消息较密集的部分).

.. literalinclude:: _code/hello.o.txt
   :caption: hello.o
   :lines: 1-15,34-43
   :emphasize-lines: 8-9

使用 Linux 程序 xxd 将整个文件转换成了可读性更好的形式,
整个文件被分为三栏::

   <地址>:   <各地址上的字节>                         <字节对应的字符>
   00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............

``.`` 号表示这个字节没有对应的可显示字符.
还可以发现, 我们要打印的字符串 "Hello World!" 也出现在了目标代码里.

4. **链接**: 得到了二进制目标代码, 但是这个程序仍然不可执行.
   并且, 还注意到在源代码中使用的 :c:func:`printf` 还仅仅是声明,
   可没有定义对应的实现呢(在 hello.o 中, 编译器留下了 ``llvm_addrsig.printf`` 记号).
   因此, 还需要将中间代码与 C 标准库相链接, 把 printf 的代码与 printf 这个符号相关联.

.. literalinclude:: _code/hello.txt
   :caption: hello
   :lines: 1,43-46,63-71,257-289,513-529,771-777,873-921

.. sidebar:: Clang 编译流程

   .. graphviz:: ../_static/graphviz/intro.compile.clang.gv

链接完成了之后, 终于得到可执行程序 ``hello`` 了.
现在, 让我们在终端运行它一下:

.. code:: bash

   ./hello

.. code::

   Hello World!

另外, clang 还会生成一个 ``hello.bc`` 文件, 那是 LLVM 的中间码.
它的生成是 LLVM 调用后端编译之前的一步.
