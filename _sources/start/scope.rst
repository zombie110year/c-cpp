.. _`作用域`:

######
作用域
######

.. todo::

   要理解作用域,
   需要了解可执行文件的结构以及帧栈的概念.

首先, 让我们来了解一下单进程单线程的程序在运行时是什么状况.

编译得到的可执行文件称为 *镜像(Image)*, 在运行时, 一个程序会创建一个进程, 它所占用的内存空间被称为 *进程地址空间*

镜像中, 会存储程序的数据段, 在加载到内存中运行时会新增会动态改变的空间.
镜像中的 "段" 也被称为 *节(Section)*.

内存布局
========

程序运行时被加载到内存中, 可以被分为几个数据 *段(Segment)*:

.text (Code/Text Segment)
   代码段. 此段中存储了可被执行的机器码.

.rodata (Read-Only Data Segment)
   只读数据段. 被 const 修饰的具有静态存储类型的变量将在此段中存储.

.rwdata (Read-Write Data Segment)
   已初始化可读写数据段. 具有静态存储类型且被初始化的变量将在此段中存储.

.bss (Block Started by Symbol)
   未初始化数据段. 具有静态存储类型且未被初始化(只声明)的变量将在此段中存储.
   此段将在运行时分配空间.
   extern 修饰的变量将在链接步骤被重新定位,
   不一定就处于 .bss 段.

heap
   堆. 在运行时分配空间.

stack
   栈. 在运行时分配空间.

其中, ``.text``, ``.rodata``, ``.rwdata`` 以及 ``.bss`` 四个段属于静态存储区.
``.text``, ``.rodata``, ``.rwdata`` 三个段在可执行文件中保存为对应的节 . 而 ``heap`` 和 ``stack`` 则不会在文件中保存, 只在运行时才分配空间.

在代码不同位置声明/定义的变量的存储类型大致如下:

.. literalinclude:: _code/show.memory.c
   :language: c
   :linenos:

1. 函数编译得到的机器码将被存储在 ``.text`` 节
2. 被初始化的 static 变量存储在 ``.rwdata`` 节
3. 被 const 修饰且初始化的 static 变量存储在 ``.rodata`` 节
4. 程序中使用的字面量也存储在 ``.rodata`` 节

.. note:: 静态存储类型的未初始化变量, 将位于 ``.bss`` 段中,
   这个段不会保存在可执行文件中, 只有运行时在内存中创建.

当程序运行起来后, ``.text``, ``.*data`` 节都被加载到内存中,
被加载到内存后, 称其为 "段",
并且, 会创建以下段:

1. ``.bss`` 段. 这个段也是静态的, 在程序一开始就分配空间, 而在函数调用时修改其中的值.
2. ``heap`` 与 ``stack``. 这两个段将在程序启动时分配到同一个段中, 此段具有确定的大小.
   在程序运行过程中, 段的容量不会改变,
   而其中 stack 和 heap 的大小会发生变化.

.. figure:: _images/intro.memory.layout.typical.svg
   :height: 400px
   :align: center

   典型内存布局

变量的存储类型与生存周期
========================

变量的 *生存周期(Life Cycle)* 指的是此变量可以被使用的一段时期.
在栈上的变量, 其生存周期受到作用域的限制,
在堆上的变量, 其生存周期由程序手动控制.

作用域分级
==========

对于一个 C 文件, 可以分为全局作用域, 函数作用域, 块作用域三个等级.
它们在语法上具有一个共同特征, 就是使用 *花括号(braces)* ``{}`` 进行界定.

全局作用域上的数据, 存储在程序的 静态
函数作用域上的数据, 会存储在随着函数调用而产生的栈帧上,
而块作用域上的数据, 会存储在函数的栈帧上.

即, 只有函数作用域的进入与退出会导致栈帧的变化.
块级作用域上的数据, 虽然也具有在作用域外无法访问的性质,
但是没有新的帧产生, 它的存储位置和函数作用域是一致的.
